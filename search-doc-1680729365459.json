[{"title":"Installation","type":0,"sectionRef":"#","url":"/Freeze/docs/Installation","content":"","keywords":""},{"title":"With Wally​","type":1,"pageTitle":"Installation","url":"/Freeze/docs/Installation#with-wally","content":"[dependencies] Freeze = &quot;duckarmor/freeze@0.0.4&quot;  "},{"title":"Demonstration","type":0,"sectionRef":"#","url":"/Freeze/docs/Demonstration","content":"","keywords":""},{"title":"API Reference​","type":1,"pageTitle":"Demonstration","url":"/Freeze/docs/Demonstration#api-reference","content":"Check out the API Reference to see what else Freeze is capable of! "},{"title":"Freeze","type":0,"sectionRef":"#","url":"/Freeze/docs/intro","content":"","keywords":""},{"title":"Freeze's General Philosophy​","type":1,"pageTitle":"Freeze","url":"/Freeze/docs/intro#freezes-general-philosophy","content":"Freeze aims to Be type safe. Types are represented in such that there are no false negative type errors.Be runtime safe. Errors will not propagate unless you are passing invalid values that the Luau type checker would have caught.Enforce immutability via table.frozenOptimize return values if no changes were made within the operation by returning the original value. "},{"title":"Prior art​","type":1,"pageTitle":"Freeze","url":"/Freeze/docs/intro#prior-art","content":"Freeze takes inspiration from: Llama by freddylistImmutable.js To the best of Luau's and my own ability.↩ "},{"title":"How does immutability help?","type":0,"sectionRef":"#","url":"/Freeze/docs/WhyImmutable","content":"","keywords":""},{"title":"Value Equality vs Reference Equality​","type":1,"pageTitle":"How does immutability help?","url":"/Freeze/docs/WhyImmutable#value-equality-vs-reference-equality","content":"First you'll want to have a simple understanding of the difference between value equality and reference equality. Let's take these two lists. local list1 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } local list2 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }  They look the same right? Are they equal? print(list1 == list2) -- false  Luau would seem to think not. That is because the == operator compares two values by reference equality. list1 and list2 are represented by two different addresses in memory. Try it out! Use print on list1 and list2 and you'll see they print two different --credit card numbers-- memory addresses. print(tostring(list1)) -- table: 0x1111111111111111 print(tostring(list1)) -- table: 0x2222222222222222  If we wanted to compare the value equality between the two lists, that could become expensive depending on the size of the lists. If we treated list1 as an immutable list, we can solve this class of problems: local list1 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } local list2 = Freeze.List.set(list1, 4, &quot;d&quot;)  Now we have two lists that we can compare against by reference equality and if they differ we can assume they also differ via value equality.  Let's look at this example from another perspective and focus on list1. local list1 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } list[4] = &quot;d&quot;  list1 has changed its value equality but its reference is still the same. Wouldn't it be nice if we could have tracked the history of list1? Maybe we need to perform some action once index 4 has been assigned. "},{"title":"Ok, but what about practical applications?​","type":1,"pageTitle":"How does immutability help?","url":"/Freeze/docs/WhyImmutable#ok-but-what-about-practical-applications","content":"In short, use of these data structures lead to simpler development time. In practical terms, React and Rodux rely on immutable data structures to detect if they should re-render or raise a changed event. Take the following example from Rodux: store.changed:connect(function(newState, oldState) -- newState and oldState are immutable &quot;snapshots&quot; of state if newState.todos ~= oldState.todos then print(&quot;something changed within our todos field!&quot;) end end)  Since newState and oldState are two unique snapshots of state, they can be referenced now or at a later date to determine what has changed. We didn't have to run an expensive value equality comparision function. Simply the basis of the reference equality (==) is all we need. If newState and oldState were not immutable, we would have a much harder time determining something had changed. "},{"title":"I can't stop reading about immutability!​","type":1,"pageTitle":"How does immutability help?","url":"/Freeze/docs/WhyImmutable#i-cant-stop-reading-about-immutability","content":"If we haven't yet satiated your desires for literature about immutability, take a look at what these other authors have to say: Immutable.jsLlama "},{"title":"Examples And Usecases","type":0,"sectionRef":"#","url":"/Freeze/docs/ExamplesAndUsecases","content":"","keywords":""},{"title":"Rendering a list of React components​","type":1,"pageTitle":"Examples And Usecases","url":"/Freeze/docs/ExamplesAndUsecases#rendering-a-list-of-react-components","content":"local Freeze = require(Packages.Freeze) local List = Freeze.List local people = { alice, bob, candice } return React.createElement(&quot;Frame&quot;, { AutomaticSize = Enum.AutomaticSize.XY, }, List.map(people, function(person) return React.createElement(ContactItem, { key = person.id, name = person.name, phone = person.phone, }) end))  "},{"title":"Updating a shallow Rodux state value​","type":1,"pageTitle":"Examples And Usecases","url":"/Freeze/docs/ExamplesAndUsecases#updating-a-shallow-rodux-state-value","content":"local Freeze = require(Packages.Freeze) local Dictionary = Freeze.Dictionary local DEFAULT_STATE = { isLoaded = false, isFoo = false, } return Rodux.createReducer(DEFAULT_STATE, { appLoaded = function(state, _action) return Dictionary.set(state, &quot;isLoaded&quot;, true) end, })  "},{"title":"Updating a deep Rodux state value​","type":1,"pageTitle":"Examples And Usecases","url":"/Freeze/docs/ExamplesAndUsecases#updating-a-deep-rodux-state-value","content":"local Freeze = require(Packages.Freeze) local Dictionary = Freeze.Dictionary local DEFAULT_STATE = { sessionId = 0, slots = { slot1 = { inventory = {} } } } return Rodux.createReducer(DEFAULT_STATE, { itemPurchased = function(state, action) local itemGuid = action.itemGuid local itemModel = action.itemModel return Dictionary.setIn(state, {&quot;slots&quot;, &quot;slot1&quot;, &quot;inventory&quot;, itemGuid}, itemModel) end, })  "},{"title":"Determining if we assisted in a KO​","type":1,"pageTitle":"Examples And Usecases","url":"/Freeze/docs/ExamplesAndUsecases#determining-if-we-assisted-in-a-ko","content":"local Freeze = require(Packages.Freeze) local List = Freeze.List type koEvent = { assistors: { entityId } -- ... } local koEvents: { koEvent } = props.koEvents local didSelfAssist = List.some(koEvent.assistors, function(assistorId) return assistorId == selfId end)  "},{"title":"Migrating From Llama","type":0,"sectionRef":"#","url":"/Freeze/docs/MigratingFromLlama","content":"","keywords":""},{"title":"Llama​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#llama","content":""},{"title":".equalObjects​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#equalobjects","content":"Not implemented. "},{"title":".Dictionary​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#dictionary","content":""},{"title":".copy​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#copy","content":"A temporary, deprecated compatibility layer exists. Use table.clone instead. "},{"title":".copyDeep​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#copydeep","content":"Not implemented. Reconsider if you really need this. "},{"title":".equals​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#equals","content":"[Freeze.Dictionary.equals] will perform value-equality instead of reference-equality.[Freeze.Dictionary.equals] only accepts two objects to compare between instead of varags arguments "},{"title":".equalsDeep​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#equalsdeep","content":"Not implemented. "},{"title":".fromLists​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#fromlists","content":"Not implemented. "},{"title":".mergeDeep​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#mergedeep","content":"Not implemented. "},{"title":".removeKeys​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#removekeys","content":"A temporary, deprecated compatibility layer exists. Use [Dictionary.remove] instead. "},{"title":".removeValues​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#removevalues","content":"A temporary, deprecated compatibility layer exists. Use [Dictionary.removeValue] instead. "},{"title":".update​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#update","content":"Freeze.[Dictionary.update] requires an updater function while Llama's was optional.Freeze.[Dictionary.update]'s updater signature is (Value) -&gt; (Value) instead of Llama's (Value, Key) -&gt; (Value).[Dictionary.update] final argument is notSetValue instead of a callback function. -- Freeze Freeze.Dictionary.update(dictionary, key, function(value) return string.upper(value) end, &quot;default value&quot;) -- Llama Llama.Dictionary.update(dictionary, key, function(value, key) return string.upper(value) end, function(key) return &quot;default value&quot; end)  "},{"title":"List​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#list","content":""},{"title":".concatDeep​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#concatdeep","content":"Not implemented. "},{"title":".copy​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#copy-1","content":"Not implemented. Consider table.clone instead. "},{"title":".copyDeep​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#copydeep-1","content":"Not implemented. Reconsider if you really need this. "},{"title":".create​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#create","content":"A temporary, deprecated compatibility layer exists. Consider table.create instead. "},{"title":".equals​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#equals-1","content":"Freeze.[List.equals] will perform value-equality instead of reference-equality.Freeze.[List.equals] only accepts two objects to compare between instead of varags arguments. "},{"title":".equalsDeep​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#equalsdeep-1","content":"Not implemented. "},{"title":".find​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#find","content":"Freeze.[List.find] accepts a predicate instead of a value.Consider table.find if you want to use a static value. -- Freeze Freeze.List.find(list, function(value) return value == &quot;foo&quot; end) -- Llama Llama.List.find(list, &quot;foo&quot;)  "},{"title":".findLast​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#findlast","content":"Freeze.[List.findLast] accepts a predicate instead of a value. -- Freeze Freeze.List.findLast(list, function(value) return value == &quot;foo&quot; end) -- Llama Llama.List.findLast(list, &quot;foo&quot;)  "},{"title":".findWhere​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#findwhere","content":"A temporary, deprecated compatibility layer exists. Please use Freeze.[List.find].The from argument is not supported. "},{"title":".findWhereLast​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#findwherelast","content":"A temporary, deprecated compatibility layer exists. Please use Freeze.[List.findLast].The from argument is not supported. "},{"title":".insert​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#insert","content":"Freeze.[List.insert] allows the provided index argument to be out of bounds. Llama would throw in this case whereas Freeze will clamp the value to either the beginning or the end of the list. "},{"title":".join​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#join","content":"A temporary, deprecated compatibility layer exists. Please use Freeze.[List.concat]. "},{"title":".removeIndices​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#removeindices","content":"A temporary, deprecated compatibility layer exists. Please use Freeze.[List.remove] instead. "},{"title":".removeValues​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#removevalues-1","content":"A temporary, deprecated compatibility layer exists. Please use Freeze.[List.removeValue] instead. "},{"title":".set​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#set","content":"Freeze.[List.set] allows the index argument to be out of bounds whereas Llama would throw.If no changes are made, Freeze.[List.set] will return the original List. "},{"title":".slice​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#slice","content":"Freeze.[List.slice] allows the index argument to be out of bounds. Will not throw.Using a negative number will slice from the end of the list. "},{"title":".splice​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#splice","content":"Not implemented. "},{"title":".toSet​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#toset","content":"Not exposed yet. "},{"title":".update​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#update-1","content":"Freeze.[List.update] requires an updater function while Llama's was optional.Freeze[List.update]'s updater signature is (Value) -&gt; (Value) instead of Llama's (Value, Key) -&gt; (Value).Freeze.[List.update] final argument is notSetValue instead of a callback function. -- Freeze Freeze.List.update(list, key, function(value) return string.upper(value) end, &quot;default value&quot;) -- Llama Llama.List.update(list, key, function(value, key) return string.upper(value) end, function(key) return &quot;default value&quot; end)  "},{"title":".zipAll​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#zipall","content":"Not implemented. "},{"title":"Set​","type":1,"pageTitle":"Migrating From Llama","url":"/Freeze/docs/MigratingFromLlama#set-1","content":"Not implemented yet. "}]