"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[237],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(a),d=r,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||l;return a?n.createElement(h,i(i({ref:t},p),{},{components:a})):n.createElement(h,i({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=a[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},4156:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var n=a(87462),r=(a(67294),a(3905));const l={sidebar_position:2},i="How does immutability help?",o={unversionedId:"WhyImmutable",id:"WhyImmutable",title:"How does immutability help?",description:"\ud83c\udfd7\ufe0f Under construction",source:"@site/docs/WhyImmutable.md",sourceDirName:".",slug:"/WhyImmutable",permalink:"/Freeze/docs/WhyImmutable",draft:!1,editUrl:"https://github.com/benbrimeyer/Freeze/edit/master/docs/WhyImmutable.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"defaultSidebar",previous:{title:"Freeze",permalink:"/Freeze/docs/intro"},next:{title:"Installation",permalink:"/Freeze/docs/Installation"}},s={},u=[{value:"Value Equality vs Reference Equality",id:"value-equality-vs-reference-equality",level:2},{value:"Ok, but what about practical applications?",id:"ok-but-what-about-practical-applications",level:2},{value:"Immutability and performance",id:"immutability-and-performance",level:2},{value:"TLDR",id:"tldr",level:2},{value:"I can&#39;t stop reading about immutability!",id:"i-cant-stop-reading-about-immutability",level:2}],p={toc:u},c="wrapper";function m(e){let{components:t,...a}=e;return(0,r.kt)(c,(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"how-does-immutability-help"},"How does immutability help?"),(0,r.kt)("div",{align:"center"},"\ud83c\udfd7\ufe0f ",(0,r.kt)("b",null,"Under construction")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Immutable data structures cannot be changed once they have been created. This allows these data structures to forever hold their current state forever, ",(0,r.kt)("strong",{parentName:"p"},"frozen in time"),", as long as you have a reference to them."),(0,r.kt)("p",null,"That sounds cool, but what does that actually mean for programmers?"),(0,r.kt)("h2",{id:"value-equality-vs-reference-equality"},"Value Equality vs Reference Equality"),(0,r.kt)("p",null,"First you'll want to have a simple understanding of the difference between ",(0,r.kt)("strong",{parentName:"p"},"value equality")," and ",(0,r.kt)("strong",{parentName:"p"},"reference equality"),"."),(0,r.kt)("p",null,"Let's take these two lists."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local list1 = { "a", "b", "c" }\nlocal list2 = { "a", "b", "c" }\n')),(0,r.kt)("p",null,"They look the same right? Are they equal?"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"print(list1 == list2)\n-- false\n")),(0,r.kt)("p",null,"Luau would seem to think not."),(0,r.kt)("p",null,"That is because the ",(0,r.kt)("inlineCode",{parentName:"p"},"==")," operator compares two values by ",(0,r.kt)("strong",{parentName:"p"},"reference equality"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"list1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"list2")," are represented by two different addresses in memory."),(0,r.kt)("p",null,"Try it out! Use ",(0,r.kt)("inlineCode",{parentName:"p"},"print")," on ",(0,r.kt)("inlineCode",{parentName:"p"},"list1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"list2")," and you'll see they print two different ",(0,r.kt)("del",{parentName:"p"},"credit card numbers")," memory addresses."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"print(tostring(list1))\n-- table: 0x1111111111111111\nprint(tostring(list2))\n-- table: 0x2222222222222222\n")),(0,r.kt)("p",null,"If we wanted to compare the value equality between the two lists, that could become expensive depending on the size of the lists. It would require traversing each list (and sub data structures!!) and comparing the values and keys with each."),(0,r.kt)("p",null,"If we treated ",(0,r.kt)("inlineCode",{parentName:"p"},"list1")," as an ",(0,r.kt)("strong",{parentName:"p"},"immutable")," list, we can solve this class of problems:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local list1 = { "a", "b", "c" }\nlocal list2 = Freeze.List.set(list1, 4, "d")\n')),(0,r.kt)("p",null,"Now we have two lists that we can compare against by ",(0,r.kt)("strong",{parentName:"p"},"reference equality")," and if they differ we can assume they also differ via ",(0,r.kt)("strong",{parentName:"p"},"value equality"),"."),(0,r.kt)("hr",null),(0,r.kt)("p",null,"Let's look at this example from another perspective and focus on ",(0,r.kt)("inlineCode",{parentName:"p"},"list1"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local list1 = { "a", "b", "c" }\nlist[4] = "d"\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"list1")," has changed its ",(0,r.kt)("strong",{parentName:"p"},"value equality")," but its reference is still the same. Wouldn't it be nice if we could have tracked the history of ",(0,r.kt)("inlineCode",{parentName:"p"},"list1"),"? Maybe we need to perform some action once ",(0,r.kt)("inlineCode",{parentName:"p"},"index 4")," has been assigned."),(0,r.kt)("h2",{id:"ok-but-what-about-practical-applications"},"Ok, but what about practical applications?"),(0,r.kt)("p",null,"In short, use of these data structures lead to simpler development time. In practical terms, React and Rodux rely on immutable data structures to detect if they should re-render or raise a changed event."),(0,r.kt)("p",null,"Take the following example from Rodux:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'store.changed:connect(function(newState, oldState)\n    -- newState and oldState are immutable "snapshots" of state\n    if newState.todos ~= oldState.todos then\n        print("something changed within our todos field!")\n    end\nend)\n')),(0,r.kt)("p",null,"Since newState and oldState are two unique snapshots of state, they can be referenced now or at a later date to determine what has changed."),(0,r.kt)("p",null,"We didn't have to run an expensive value equality comparison function. Simply the basis of the reference equality (",(0,r.kt)("inlineCode",{parentName:"p"},"=="),") is all we need."),(0,r.kt)("p",null,"If newState and oldState were not immutable, we would have a much harder time determining something had changed."),(0,r.kt)("p",null,"For more practical examples, check out our ",(0,r.kt)("a",{parentName:"p",href:"/docs/ExamplesAndUsecases"},"Examples and Usecases")," page."),(0,r.kt)("h2",{id:"immutability-and-performance"},"Immutability and performance"),(0,r.kt)("p",null,"There are some readers who may be concerned that creating new tables instead of reusing old ones for operations may not be performant enough for their use cases."),(0,r.kt)("p",null,"Rest assured that Luau is a ",(0,r.kt)("em",{parentName:"p"},"very")," performant language and immutability may be worth the benefits as it can reduce code complexity and open up new solutions that were not feasible without these structures (examples: state time travel, state debugging, creating an undo/redo stack)."),(0,r.kt)("p",null,"Consider immutable data structures as a tool like any other high level concepts you've learned. If you are using immutable data structures in one part of your project, it does not mean you ",(0,r.kt)("strong",{parentName:"p"},"must")," use them in all other systems where the benefits and tradeoffs don't make sense."),(0,r.kt)("h2",{id:"tldr"},"TLDR"),(0,r.kt)("p",null,"In summary, the following are core key points that immutable data structures can help with."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Without immutable data structures, state mutations can turn into spaghetti really quickly. Immutability helps employ robust practices and encourage mindfulness when designing all the ways state can change."),(0,r.kt)("li",{parentName:"ol"},"When detecting state changes, immutability helps by using a cheap ",(0,r.kt)("inlineCode",{parentName:"li"},"==")," operation for reference equality instead of an expensive equality checking function by leaning on an inherit property of immutability in Luau; a new table will be produced every time its contents are changed."),(0,r.kt)("li",{parentName:"ol"},"It's difficult to robustly keep track of how state changes over time. Immutability helps by inherently leaving a breadcrumb trail of previous states to easily store for debugging.")),(0,r.kt)("h2",{id:"i-cant-stop-reading-about-immutability"},"I can't stop reading about immutability!"),(0,r.kt)("p",null,"If we haven't yet satiated your desires for literature about immutability, take a look at what these other authors have to say:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://immutable-js.com/#introduction"},"Immutable.js")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://freddylist.github.io/llama/"},"Llama"))))}m.isMDXComponent=!0}}]);