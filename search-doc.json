[
    {
        "title": "Demonstration",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/docs/Demonstration",
        "content": "",
        "keywords": ""
    },
    {
        "title": "API Reference​",
        "type": 1,
        "pageTitle": "Demonstration",
        "url": "/freeze/docs/Demonstration#api-reference",
        "content": "Check out the API Reference to see what else freeze is capable of! "
    },
    {
        "title": "freeze",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/api/freeze",
        "content": "",
        "keywords": ""
    },
    {
        "title": "Properties​",
        "type": 1,
        "pageTitle": "freeze",
        "url": "/freeze/api/freeze#properties",
        "content": " "
    },
    {
        "title": "None​",
        "type": 1,
        "pageTitle": "freeze",
        "url": "/freeze/api/freeze#None",
        "content": "&lt;/&gt; freeze.None: None Since lua tables cannot distinguish between values not being present and a value of nil,freeze.None exists to represent values that should be interpreted as nil. This is useful when removing values with functions such as freeze.Dictionary.merge. "
    },
    {
        "title": "Functions​",
        "type": 1,
        "pageTitle": "freeze",
        "url": "/freeze/api/freeze#functions",
        "content": " "
    },
    {
        "title": "isEmpty​",
        "type": 1,
        "pageTitle": "freeze",
        "url": "/freeze/api/freeze#isEmpty",
        "content": "&lt;/&gt; freeze.isEmpty() → boolean Returns true if the collection is empty. freeze.isEmpty({}) -- true  "
    },
    {
        "title": "How does immutability help?",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/docs/WhyImmutable",
        "content": "",
        "keywords": ""
    },
    {
        "title": "Value Equality vs Reference Equality​",
        "type": 1,
        "pageTitle": "How does immutability help?",
        "url": "/freeze/docs/WhyImmutable#value-equality-vs-reference-equality",
        "content": "First you'll want to have a simple understanding of the difference between value equality and reference equality. Let's take these two lists. local list1 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } local list2 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }  They look the same right? Are they equal? print(list1 == list2) -- false  Luau would seem to think not. That is because the == operator compares two values by reference equality. list1 and list2 are represented by two different addresses in memory. Try it out! Use print on list1 and list2 and you'll see they print two different credit card numbers memory addresses. print(tostring(list1)) -- table: 0x1111111111111111 print(tostring(list2)) -- table: 0x2222222222222222  If we wanted to compare the value equality between the two lists, that could become expensive depending on the size of the lists. It would require traversing each list (and sub data structures!!) and comparing the values and keys with each. If we treated list1 as an immutable list, we can solve this class of problems: local list1 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } local list2 = freeze.List.set(list1, 4, &quot;d&quot;)  Now we have two lists that we can compare against by reference equality and if they differ we can assume they also differ via value equality.  Let's look at this example from another perspective and focus on list1. local list1 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } list[4] = &quot;d&quot;  list1 has changed its value equality but its reference is still the same. Wouldn't it be nice if we could have tracked the history of list1? Maybe we need to perform some action once index 4 has been assigned. "
    },
    {
        "title": "Ok, but what about practical applications?​",
        "type": 1,
        "pageTitle": "How does immutability help?",
        "url": "/freeze/docs/WhyImmutable#ok-but-what-about-practical-applications",
        "content": "In short, use of these data structures lead to simpler development time. In practical terms, React and Rodux rely on immutable data structures to detect if they should re-render or raise a changed event. Take the following example from Rodux: store.changed:connect(function(newState, oldState) -- newState and oldState are immutable &quot;snapshots&quot; of state if newState.todos ~= oldState.todos then print(&quot;something changed within our todos field!&quot;) end end)  Since newState and oldState are two unique snapshots of state, they can be referenced now or at a later date to determine what has changed. We didn't have to run an expensive value equality comparison function. Simply the basis of the reference equality (==) is all we need. If newState and oldState were not immutable, we would have a much harder time determining something had changed. For more practical examples, check out our Examples and Usecases page. "
    },
    {
        "title": "Immutability and performance​",
        "type": 1,
        "pageTitle": "How does immutability help?",
        "url": "/freeze/docs/WhyImmutable#immutability-and-performance",
        "content": "There are some readers who may be concerned that creating new tables instead of reusing old ones for operations may not be performant enough for their use cases. Rest assured that Luau is a very performant language and immutability may be worth the benefits as it can reduce code complexity and open up new solutions that were not feasible without these structures (examples: state time travel, state debugging, creating an undo/redo stack). Consider immutable data structures as a tool like any other high level concepts you've learned. If you are using immutable data structures in one part of your project, it does not mean you must use them in all other systems where the benefits and tradeoffs don't make sense. "
    },
    {
        "title": "TLDR​",
        "type": 1,
        "pageTitle": "How does immutability help?",
        "url": "/freeze/docs/WhyImmutable#tldr",
        "content": "In summary, the following are core key points that immutable data structures can help with. Without immutable data structures, state mutations can turn into spaghetti really quickly. Immutability helps employ robust practices and encourage mindfulness when designing all the ways state can change.When detecting state changes, immutability helps by using a cheap == operation for reference equality instead of an expensive equality checking function by leaning on an inherit property of immutability in Luau; a new table will be produced every time its contents are changed.It's difficult to robustly keep track of how state changes over time. Immutability helps by inherently leaving a breadcrumb trail of previous states to easily store for debugging. "
    },
    {
        "title": "I can't stop reading about immutability!​",
        "type": 1,
        "pageTitle": "How does immutability help?",
        "url": "/freeze/docs/WhyImmutable#i-cant-stop-reading-about-immutability",
        "content": "If we haven't yet satiated your desires for literature about immutability, take a look at what these other authors have to say: Immutable.jsLlama "
    },
    {
        "title": "Installation",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/docs/Installation",
        "content": "",
        "keywords": ""
    },
    {
        "title": "With Wally​",
        "type": 1,
        "pageTitle": "Installation",
        "url": "/freeze/docs/Installation#with-wally",
        "content": "[dependencies] freeze = &quot;ahmoin/freeze@0.1.0&quot;  "
    },
    {
        "title": "freeze",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/docs/intro",
        "content": "",
        "keywords": ""
    },
    {
        "title": "Nested Data Structures​",
        "type": 1,
        "pageTitle": "freeze",
        "url": "/freeze/docs/intro#nested-data-structures",
        "content": "freeze also has a few power tools at your disposal to allow for reading and operating on nested data structures. These include getIn, setIn, mergeIn, and updateIn, found on Dictionary. "
    },
    {
        "title": "freeze's General Philosophy​",
        "type": 1,
        "pageTitle": "freeze",
        "url": "/freeze/docs/intro#freezes-general-philosophy",
        "content": "freeze aims to Be type safe. Types are represented in such that there are no false negative type errors.Be runtime safe. Errors will not propagate unless you are passing invalid values that the Luau type checker would have caught.Enforce immutability via table.frozenOptimize return values if no changes were made within the operation by returning the original value. "
    },
    {
        "title": "Prior art​",
        "type": 1,
        "pageTitle": "freeze",
        "url": "/freeze/docs/intro#prior-art",
        "content": "freeze takes inspiration from: Llama by freddylistImmutable.js To the best of Luau's and my own ability.↩ "
    },
    {
        "title": "Examples And Usecases",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/docs/ExamplesAndUsecases",
        "content": "",
        "keywords": ""
    },
    {
        "title": "Rendering a list of React components​",
        "type": 1,
        "pageTitle": "Examples And Usecases",
        "url": "/freeze/docs/ExamplesAndUsecases#rendering-a-list-of-react-components",
        "content": "local freeze = require(Packages.freeze) local List = freeze.List local people = { alice, bob, candice } return React.createElement(&quot;Frame&quot;, { AutomaticSize = Enum.AutomaticSize.XY, }, List.map(people, function(person) return React.createElement(ContactItem, { key = person.id, name = person.name, phone = person.phone, }) end))  "
    },
    {
        "title": "Updating a shallow Rodux state value​",
        "type": 1,
        "pageTitle": "Examples And Usecases",
        "url": "/freeze/docs/ExamplesAndUsecases#updating-a-shallow-rodux-state-value",
        "content": "local freeze = require(Packages.freeze) local Dictionary = freeze.Dictionary local DEFAULT_STATE = { isLoaded = false, isFoo = false, } return Rodux.createReducer(DEFAULT_STATE, { appLoaded = function(state, _action) return Dictionary.set(state, &quot;isLoaded&quot;, true) end, })  "
    },
    {
        "title": "Updating a deep Rodux state value​",
        "type": 1,
        "pageTitle": "Examples And Usecases",
        "url": "/freeze/docs/ExamplesAndUsecases#updating-a-deep-rodux-state-value",
        "content": "local freeze = require(Packages.freeze) local Dictionary = freeze.Dictionary local DEFAULT_STATE = { sessionId = 0, slots = { slot1 = { inventory = {} } } } return Rodux.createReducer(DEFAULT_STATE, { itemPurchased = function(state, action) local itemGuid = action.itemGuid local itemModel = action.itemModel return Dictionary.setIn(state, {&quot;slots&quot;, &quot;slot1&quot;, &quot;inventory&quot;, itemGuid}, itemModel) end, })  "
    },
    {
        "title": "Determining if we assisted in a KO​",
        "type": 1,
        "pageTitle": "Examples And Usecases",
        "url": "/freeze/docs/ExamplesAndUsecases#determining-if-we-assisted-in-a-ko",
        "content": "local freeze = require(Packages.freeze) local List = freeze.List type koEvent = { assistors: { entityId } -- ... } local koEvents: { koEvent } = props.koEvents local didSelfAssist = List.some(koEvent.assistors, function(assistorId) return assistorId == selfId end)  "
    },
    {
        "title": "Migrating From Llama",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/docs/MigratingFromLlama",
        "content": "",
        "keywords": ""
    },
    {
        "title": "Llama​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#llama",
        "content": ""
    },
    {
        "title": ".equalObjects​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#equalobjects",
        "content": "Not implemented. "
    },
    {
        "title": ".Dictionary​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#dictionary",
        "content": ""
    },
    {
        "title": ".copy​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#copy",
        "content": "A temporary, deprecated compatibility layer exists. Use table.clone instead. "
    },
    {
        "title": ".copyDeep​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#copydeep",
        "content": "Not implemented. Reconsider if you really need this. "
    },
    {
        "title": ".equals​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#equals",
        "content": "freeze.Dictionary.equals will perform value-equality instead of reference-equality.freeze.Dictionary.equals only accepts two objects to compare between instead of varags arguments "
    },
    {
        "title": ".equalsDeep​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#equalsdeep",
        "content": "Not implemented. "
    },
    {
        "title": ".fromLists​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#fromlists",
        "content": "Not implemented. "
    },
    {
        "title": ".map​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#map",
        "content": "freeze.Dictionary.map requires the mapper argument to return two arguments for value and key. "
    },
    {
        "title": ".mergeDeep​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#mergedeep",
        "content": "Not implemented. "
    },
    {
        "title": ".removeKeys​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#removekeys",
        "content": "A temporary, deprecated compatibility layer exists. Use Dictionary.remove instead. "
    },
    {
        "title": ".removeValues​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#removevalues",
        "content": "A temporary, deprecated compatibility layer exists. Use Dictionary.removeValue instead. "
    },
    {
        "title": ".update​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#update",
        "content": "freeze.Dictionary.update requires an updater function while Llama's was optional.freeze.Dictionary.update's updater signature is (Value) -&gt; (Value) instead of Llama's (Value, Key) -&gt; (Value).freeze.Dictionary.update final argument is notSetValue instead of a callback function. -- freeze freeze.Dictionary.update(dictionary, key, function(value) return string.upper(value) end, &quot;default value&quot;) -- Llama Llama.Dictionary.update(dictionary, key, function(value, key) return string.upper(value) end, function(key) return &quot;default value&quot; end)  "
    },
    {
        "title": "List​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#list",
        "content": ""
    },
    {
        "title": ".concatDeep​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#concatdeep",
        "content": "Not implemented. "
    },
    {
        "title": ".copy​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#copy-1",
        "content": "Not implemented. Consider table.clone instead. "
    },
    {
        "title": ".copyDeep​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#copydeep-1",
        "content": "Not implemented. Reconsider if you really need this. "
    },
    {
        "title": ".create​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#create",
        "content": "A temporary, deprecated compatibility layer exists. Consider table.create instead. "
    },
    {
        "title": ".equals​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#equals-1",
        "content": "freeze.List.equals will perform value-equality instead of reference-equality.freeze.List.equals only accepts two objects to compare between instead of varags arguments. "
    },
    {
        "title": ".equalsDeep​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#equalsdeep-1",
        "content": "Not implemented. "
    },
    {
        "title": ".find​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#find",
        "content": "freeze.List.find accepts a predicate instead of a value.freeze.List.find returns a value instead of index.Consider table.find if you want to use a static value. -- freeze local value = freeze.List.find(list, function(value) return value == &quot;foo&quot; end) -- Llama local index = Llama.List.find(list, &quot;foo&quot;) -- Luau local index = table.find(list, &quot;foo&quot;)  "
    },
    {
        "title": ".findLast​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#findlast",
        "content": "Not implemented. "
    },
    {
        "title": ".findWhere​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#findwhere",
        "content": "A temporary, deprecated compatibility layer exists. Please use freeze.List.find.The from argument is not supported. "
    },
    {
        "title": ".findWhereLast​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#findwherelast",
        "content": "A temporary, deprecated compatibility layer exists.The from argument is not supported. "
    },
    {
        "title": ".insert​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#insert",
        "content": "freeze.List.insert allows the provided index argument to be out of bounds. Llama would throw in this case whereas freeze will clamp the value to either the beginning or the end of the list. "
    },
    {
        "title": ".join​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#join",
        "content": "A temporary, deprecated compatibility layer exists. Please use freeze.List.concat. "
    },
    {
        "title": ".removeIndices​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#removeindices",
        "content": "A temporary, deprecated compatibility layer exists. Please use freeze.List.remove. "
    },
    {
        "title": ".removeValues​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#removevalues-1",
        "content": "A temporary, deprecated compatibility layer exists. Please use freeze.List.removeValue. "
    },
    {
        "title": ".set​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#set",
        "content": "freeze.List.set allows the index argument to be out of bounds whereas Llama would throw.If no changes are made, freeze.List.set will return the original List. "
    },
    {
        "title": ".slice​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#slice",
        "content": "freeze.List.slice allows the index argument to be out of bounds. Will not throw.Using a negative number will slice from the end of the list. "
    },
    {
        "title": ".splice​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#splice",
        "content": "Not implemented. "
    },
    {
        "title": ".toSet​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#toset",
        "content": "Not exposed yet. "
    },
    {
        "title": ".update​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#update-1",
        "content": "freeze.List.update requires an updater function while Llama's was optional.freeze.List.update's updater signature is (Value) -&gt; (Value) instead of Llama's (Value, Key) -&gt; (Value).freeze.List.update's final argument is notSetValue instead of a callback function. -- freeze freeze.List.update(list, key, function(value) return string.upper(value) end, &quot;default value&quot;) -- Llama Llama.List.update(list, key, function(value, key) return string.upper(value) end, function(key) return &quot;default value&quot; end)  "
    },
    {
        "title": ".zipAll​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#zipall",
        "content": "Not implemented. "
    },
    {
        "title": "Set​",
        "type": 1,
        "pageTitle": "Migrating From Llama",
        "url": "/freeze/docs/MigratingFromLlama#set-1",
        "content": "Not implemented yet. "
    },
    {
        "title": "Dictionary",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/api/Dictionary",
        "content": "",
        "keywords": ""
    },
    {
        "title": "Functions​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#functions",
        "content": " "
    },
    {
        "title": "count​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#count",
        "content": "&lt;/&gt; Dictionary.count( dictionary: {[Key]: Value}, predicate: (( Value, Key ) → boolean)? ) → number Returns the number of pairs that match the predicate. If the predicate is not given, all pairs will be considered a match. Dictionary.count({ a = 1, b = 2, c = 3 }).count() -- 3 Dictionary.count({ a = 1, b = 2, c = 3 }, function(value, key) return value % 2 == 0 end) -- 1   "
    },
    {
        "title": "equals​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#equals",
        "content": "&lt;/&gt; Dictionary.equals( dictionaryA: {[Key]: Value}, dictionaryB: any ) → boolean Returns true if both Dictionaries have value equality. info If you only require reference equal, use the == operator. local dictionary1 = { a = 1, b = 2, c = 3 } local dictionary2 = { a = 1, b = 2, c = 3 } Dictionary.equals(dictionary1, dictionary2) -- true   "
    },
    {
        "title": "every​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#every",
        "content": "&lt;/&gt; Dictionary.every( list: {[Key]: Value}, predicate: ( Value, Key ) → boolean ) → boolean Returns true if predicate returns true for all entries in the Dictionary. Dictionary.every({ a = 1, b = 2, c = 3 }, function(value, key) return value &lt; 10 end) -- true   "
    },
    {
        "title": "filter​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#filter",
        "content": "&lt;/&gt; Dictionary.filter( dictionary: {[Key]: Value}, predicate: (( Value, Key ) → boolean) ) → {[Key]: Value} Returns a Dictionary of only entries for which the predicate function returns true. Dictionary.filter({ a = 1, b = 2, c = 3, d = 4 }, function(value, key) return value % 2 == 0 end) -- { b = 2, d = 4 }   "
    },
    {
        "title": "filterNot​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#filterNot",
        "content": "&lt;/&gt; Dictionary.filterNot( dictionary: {[Key]: Value}, predicate: ( Value, Key ) → boolean ) → {[Key]: Value} Returns a Dictionary of only entries for which the predicate function returns false. Dictionary.filterNot({ a = 1, b = 2, c = 3, d = 4 }, function(value, key) return value % 2 == 0 end) -- { a = 1, c = 3 }   "
    },
    {
        "title": "find​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#find",
        "content": "&lt;/&gt; Dictionary.find( dictionary: {[Key]: Value}, predicate: ( Value, Key ) → boolean, notSetValue: Value? ) → Value? Returns the first value for which the predicate returns true. Dictionary.find({ a = 1, b = 2, c = 3 }, function(value, key) return value % 2 == 0 end) -- 2   "
    },
    {
        "title": "findKey​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#findKey",
        "content": "&lt;/&gt; Dictionary.findKey( dictionary: {[Key]: Value}, predicate: ( Value, Key ) → boolean, notSetValue: Key? ) → Key? Returns the first key for which the predicate returns true. Dictionary.findKey({ a = 1, b = 2, c = 3 }, function(value, key) return value % 2 == 0 end) -- &quot;b&quot;   "
    },
    {
        "title": "findPair​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#findPair",
        "content": "&lt;/&gt; Dictionary.findPair( list: {[Key]: Value}, predicate: (( Value, Key ) → boolean) ) → ( Key?, Value? ) Returns the first (key, value) pair for which the predicate returns true. Dictionary.findPair({ a = 1, b = 2 c = 3, d = 4 }, function(value, key) return value % 2 == 0 end) -- ( &quot;b&quot;, 2 )   "
    },
    {
        "title": "flatten​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#flatten",
        "content": "&lt;/&gt; Dictionary.flatten( dictionary: {[any]: any}, depth: number? ) → {[any]: any} Returns a flattened dictionary by combining keys of the lowest depth. If provided depth, the flattening will early-out. Dictionary.flatten({ foo = 1, foobar = { bar = 2, baz = { etc = 3, }, }, }) -- { foo = 1, bar = 2, etc = 3 }   "
    },
    {
        "title": "flip​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#flip",
        "content": "&lt;/&gt; Dictionary.flip(dictionary: {[Key]: Value}) → {[Value]: Key} Returns a new map where keys and values are flipped. Dictionary.flip({ a = &quot;x&quot;, b = &quot;y&quot;, c = &quot;z&quot; ) -- { x = &quot;a&quot;, y = &quot;b&quot;, z = &quot;c&quot; }   "
    },
    {
        "title": "forEach​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#forEach",
        "content": "&lt;/&gt; Dictionary.forEach( dictionary: {[Key]: Value}, sideEffect: ( Value, Key ) → boolean ) → number While the Dictionary is iterated, the sideEffect is executed for every entry. If any call of the sideEffect returns false, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false). Dictionary.forEach({ a = 10, b = 20, c = -10, d = 30 }, function(value, key) return value &gt; 0 end) -- 3   "
    },
    {
        "title": "get​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#get",
        "content": "&lt;/&gt; Dictionary.get( dictionary: {[Key]: Value}, key: Key, notSetValue: Value? ) → Value? Returns the value at the given key, otherwise returns notSetValue if the given value is not found. Dictionary.get({ a = 1, b = 2, c = 3 }, &quot;a&quot;) -- 1 Dictionary.get({ a = 1, b = 2, c = 3 }, &quot;foobar&quot;, &quot;default&quot;) -- &quot;default&quot;   "
    },
    {
        "title": "getIn​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#getIn",
        "content": "&lt;/&gt; Dictionary.getIn( dictionary: {[any]: any}, keyPath: {any}, notSetValue: Value? ) → Value? Returns the value if found by following a path of keys, otherwise returns notSetValue if the given value is nil. local dictionary = { a = { b = &quot;c&quot; } } Dictionary.getIn(dictionary), { &quot;a&quot;, &quot;b&quot; }) -- &quot;c&quot;   "
    },
    {
        "title": "has​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#has",
        "content": "&lt;/&gt; Dictionary.has( dictionary: {[Key]: Value}, key: Key ) → boolean Returns true if the key exists within the Dictionary. Dictionary.has({ a = 1, b = 2, c = 3 }, &quot;b&quot;) -- true   "
    },
    {
        "title": "hasIn​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#hasIn",
        "content": "&lt;/&gt; Dictionary.hasIn( dictionary: {[Key]: Value}, keyPath: {any} ) → boolean Returns true if the value is found by following a path of keys. local dictionary = { a = { b = &quot;c&quot; } } Dictionary.hasIn(dictionary, { &quot;a&quot;, &quot;b&quot; }) -- true   "
    },
    {
        "title": "includes​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#includes",
        "content": "&lt;/&gt; Dictionary.includes( dictionary: {[Key]: Value}, value: Value ) → boolean Returns true if the value is found within the Dictionary. Dictionary.includes({ a = 1, b = 2, c = 3 }, 2) -- true   "
    },
    {
        "title": "joinAsString​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#joinAsString",
        "content": "&lt;/&gt; Dictionary.joinAsString( dictionary: {[Key]: Value}, separator: string? ) → string Joins values together as a string, inserting a separator between each. The default separator is &quot;,&quot;. Dictionary.joinAsString({ a = 1, b = 2, c = 3 }, &quot;, &quot;) -- &quot;a=1, b=2, c=3&quot;   "
    },
    {
        "title": "keys​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#keys",
        "content": "&lt;/&gt; Dictionary.keys(dictionary: {[Key]: Value}) → {Key} Returns a list of keys. Order is undefined. Dictionary.keys({ a = 1, b = 2, c = 3 }) -- { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "map​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#map",
        "content": "&lt;/&gt; Dictionary.map( dictionary: {[Key]: Value}, mapper: ( Value, Key ) → ( NewValue, NewKey ) ) → {[NewKey]: NewValue?} Returns a new Dictionary with keys and values passed through a mapper function. Returning a second value in the mapper function will reassign the key. Dictionary.map({ a = 1, b = 2, c = 3 }, function(value, key) return value * 10, key end) -- { a = 10, b = 20, c = 30 }   "
    },
    {
        "title": "max​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#max",
        "content": "&lt;/&gt; Dictionary.max( dictionary: {[Key]: Value}, comparator: (( Value, Value ) → boolean)? ) → ( Value, Key? ) Returns the maximum value and key in this dictionary. If any values are comparatively equivalent, the first one found will be returned. (Order is undefined.) The comparator is used in the same way as table.sort. If it is not provided, the default comparator is &gt;. Dictionary.max({ a = 10, b = 200, c = 30 }) -- ( 200, &quot;c&quot; ) Dictionary.max({ alice = child, bertram = teen, charlie = adult }, function(personA, personB) return personA.age &gt; personB.age end) -- ( adult, &quot;charlie&quot; )   "
    },
    {
        "title": "merge​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#merge",
        "content": "&lt;/&gt; Dictionary.merge(...: {[Key]: Value}) → {[any]: any} Returns a merged result of all given dictionaries. If freeze.None is a value assigned to a key, it will delete that key from the resulting dictionary. Dictionary.merge({ a = 10, b = 20 }, { c = 30 }) -- { a = 10, b = 20, c = 30 } Dictionary.merge({ a = 10, b = 20 }, { c = 30, d = 40 }, { b = freeze.None }) -- { a = 10, c = 30, d = 40 }   "
    },
    {
        "title": "mergeIn​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#mergeIn",
        "content": "&lt;/&gt; Dictionary.mergeIn( dictionary: {[any]: any}, keyPath: {any}, ...: any ) → {[any]: any} A combination of updateIn and merge, returning a new dictionary, but performing a merge at the point arrived by following the key path. local dictionary = { persons = { alice = { age = 10, }, }, } Dictionary.mergeIn(dictionary, { &quot;persons&quot;, &quot;alice&quot; }, { age = 11 }) -- { persons = { alice = { age = 11 } } }   "
    },
    {
        "title": "min​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#min",
        "content": "&lt;/&gt; Dictionary.min( dictionary: {[Key]: Value}, comparator: (( Value, Value ) → boolean)? ) → ( Value, Key? ) Returns the minium value and key in this dictionary. If any values are comparatively equivalent, the first one found will be returned. (Order is undefined.) The comparator is used in the same way as table.sort. If it is not provided, the default comparator is &gt;. Dictionary.min({ a = 10, b = 200, c = 30 }) -- ( 10, &quot;a&quot; ) Dictionary.min({ alice = child, bertram = teen, charlie = adult }, function(personA, personB) return personA.age &gt; personB.age end) -- ( child, &quot;alice&quot; )   "
    },
    {
        "title": "remove​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#remove",
        "content": "&lt;/&gt; Dictionary.remove( dictionary: {[Key]: Value}, ...: Key ) → {[Key]: Value} Returns a Dictionary which excludes the given keys. Dictionary.remove({ a = 10, b = 20, c = 30 }).remove(&quot;c&quot;) -- { a = 10, b = 20 } Dictionary.remove({ a = 10, b = 20, c = 30 }).remove(&quot;b&quot;, &quot;c&quot;) -- { a = 10 }   "
    },
    {
        "title": "removeIn​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#removeIn",
        "content": "&lt;/&gt; Dictionary.removeIn( dictionary: {[any]: any}, keyPath: {any} ) → {[any]: any} Returns a new map having removed the value at this keyPath. Will create a new path if it does not exist. Dictionary.removeIn({ a = { b = { &quot;c&quot; } } }, { &quot;a&quot;, &quot;b&quot; }) -- { a = {} }   "
    },
    {
        "title": "removeValue​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#removeValue",
        "content": "&lt;/&gt; Dictionary.removeValue( dictionary: {[Key]: Value}, value: Value ) → {[Key]: Value} Returns a new map having removed the all pairs with the given value. Dictionary.removeValue({ a = 10, b = 20, c = 30 }, 10) -- { b = 20, c = 30 }   "
    },
    {
        "title": "set​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#set",
        "content": "&lt;/&gt; Dictionary.set( dictionary: {[Key]: Value}, key: Key, value: Value ) → {[Key]: Value} Returns a Dictionary which includes value at key. If key already exists, it will be replaced. Dictionary.set({ a = 10, b = 20, c = 30 }, &quot;a&quot;, 100) -- { a = 100, b = 20, c = 30 }   "
    },
    {
        "title": "setIn​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#setIn",
        "content": "&lt;/&gt; Dictionary.setIn( dictionary: {[any]: any}, keyPath: {any}, value: any ) → {[any]: any} Returns a dictionary having set value at this keyPath. If any keys in keyPath do not exist, a new dictionary will be created at that key. local dictionary = { persons = { alice = { age = 10, } }, } Dictionary.setIn(dictionary, { &quot;persons&quot;, &quot;alice&quot;, &quot;age&quot; }, 11) -- { persons = { alice = { age = 11 } } }   "
    },
    {
        "title": "some​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#some",
        "content": "&lt;/&gt; Dictionary.some( dictionary: {[Key]: Value}, predicate: ( Value, Key ) → boolean ) → boolean Returns true if predicate returns true for any entry in the dictionary. Dictionary.some({ a = 1, b = 2, c = 3 }), function(value, key) return value % 2 == 0 end) -- true   "
    },
    {
        "title": "update​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#update",
        "content": "&lt;/&gt; Dictionary.update( dictionary: {[Key]: Value}, key: Key, updater: (Value?) → Value, notSetValue: Value? ) → {[Key]: Value} Returns a dictionary with the entry at key updated to the result of updater. If the entry does not exist, updater will be given notSetValue or nil. Dictionary.update({ a = 10, b = 20, c = 30 }, &quot;a&quot;, function(value) return value * 100 end) -- { a = 1000, b = 20, c = 30 } Dictionary.update({ a = 10, b = 20, c = 30 }, &quot;d&quot;, function(value) return value * 100 end, 1) -- { a = 10, b = 20, c = 30, d = 100 }   "
    },
    {
        "title": "updateIn​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#updateIn",
        "content": "&lt;/&gt; Dictionary.updateIn( dictionary: {[any]: any}, keyPath: {any}, updater: (any) → any, notSetValue: any? ) → {[any]: any} Returns a Dictionary with the entry at keyPath updated to the result of updater. If any entry does not exist along keyPath, an empty Dictionary will be created in its place. If the final entry does not exist, updater will be given notSetValue or nil. local dictionary = { persons = { alice = { age = 10, }, }, } Dictionary.updateIn({ &quot;persons&quot;, &quot;alice&quot;, &quot;age&quot; }, function(value: number) assert(value, &quot;will exist&quot;) return value + 1 end) -- { persons = { alice = { age = 11 } } }   "
    },
    {
        "title": "values​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#values",
        "content": "&lt;/&gt; Dictionary.values(dictionary: {[Key]: Value}) → {Value} Returns a list of values. Order is undefined. Dictionary.values({ a = 1, b = 2, c = 3 }) -- { 1, 2, 3 }   "
    },
    {
        "title": "join​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#join",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [Dictionary.merge] instead. Dictionary.join(...: {[Key]: Value}) → {[any]: any}   "
    },
    {
        "title": "removeKey​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#removeKey",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [Dictionary.remove] instead. Dictionary.removeKey( dictionary: {[Key]: Value}, key: Key ) → {[Key]: Value}   "
    },
    {
        "title": "removeKeys​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#removeKeys",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [Dictionary.remove] instead. Dictionary.removeKeys( dictionary: {[Key]: Value}, ...: Key ) → {[Key]: Value}   "
    },
    {
        "title": "removeValues​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#removeValues",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [Dictionary.removeValue] instead. Dictionary.removeValues( dictionary: {[Key]: Value}, ...: Value ) → {[Key]: Value}   "
    },
    {
        "title": "toArray​",
        "type": 1,
        "pageTitle": "Dictionary",
        "url": "/freeze/api/Dictionary#toArray",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [Dictionary.values] instead. Dictionary.toArray(dictionary: {[Key]: Value}) → {Value}  "
    },
    {
        "title": "List",
        "type": 0,
        "sectionRef": "#",
        "url": "/freeze/api/List",
        "content": "",
        "keywords": ""
    },
    {
        "title": "Functions​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#functions",
        "content": " "
    },
    {
        "title": "butLast​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#butLast",
        "content": "&lt;/&gt; List.butLast(list: {Value}) → {Value} Returns a List containing all entires except the last. Equivalent to slice(1, -1). See List.slice for more information. List.butLast({ 1, 2, 3 }) -- { 1, 2 }   "
    },
    {
        "title": "concat​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#concat",
        "content": "&lt;/&gt; List.concat(...: {Value}) → {Value} Returns a List of the same type concatenated to given arguments. List.concat({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, { &quot;d&quot;, &quot;e&quot;, &quot;f&quot; }) -- { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; }   "
    },
    {
        "title": "count​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#count",
        "content": "&lt;/&gt; List.count( list: {Value}, predicate: (( Value, number ) → boolean)? ) → number Returns the number of entries that match the predicate. If the predicate is not given, all entries will be considered a match. List.count({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }) -- 3 List.count({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, function(value) return value == &quot;b&quot; end) -- 1   "
    },
    {
        "title": "equals​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#equals",
        "content": "&lt;/&gt; List.equals( listA: {Value}, listB: any ) → boolean Returns true if both Lists have value equality. local list1 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } local list2 = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } List.equals(list1, list2) -- true   "
    },
    {
        "title": "every​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#every",
        "content": "&lt;/&gt; List.every( list: {Value}, predicate: ( Value, number ) → boolean ) → boolean Returns true if predicate returns true for all entries in the list. List.every({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, function(value, key) return string.lower(value) == value end) -- true   "
    },
    {
        "title": "filter​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#filter",
        "content": "&lt;/&gt; List.filter( list: {Value}, predicate: ( Value, number ) → boolean ) → {Value} Returns a new List of only entries for which the predicate function returns true. List.filter({ 1, 2, 3, 4 }, function(value, key) return value % 2 == 0 end) -- { 2, 4 }   "
    },
    {
        "title": "filterNot​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#filterNot",
        "content": "&lt;/&gt; List.filterNot( list: {Value}, predicate: ( Value, number ) → boolean ) → {Value} Returns a new List of only entries for which the predicate function returns false. List.filterNot({ 1, 2, 3, 4 }, function(value, index) return value % 2 == 0 end) -- { 1, 3 }   "
    },
    {
        "title": "find​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#find",
        "content": "&lt;/&gt; List.find( list: {Value}, predicate: ( Value, number ) → boolean, notSetValue: Value? ) → Value? Returns the first value for which the predicate returns true. List.find({ &quot;a&quot;, &quot;B&quot;, &quot;c&quot; }, function(value, key) return value == string.upper(v) end) -- &quot;B&quot;   "
    },
    {
        "title": "findIndex​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#findIndex",
        "content": "&lt;/&gt; List.findIndex( list: {Value}, predicate: ( Value, number ) → boolean ) → number? Returns the first index for which the predicate returns true. List.findIndex({ &quot;a&quot;, &quot;B&quot;, &quot;c&quot; }, function(value, index) return value == string.upper(v) end) -- 2   "
    },
    {
        "title": "findPair​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#findPair",
        "content": "&lt;/&gt; List.findPair( list: {Value}, predicate: ( Value, number ) → boolean ) → ( number?, Value? ) Returns the first [index, value] pair for which the predicate returns true. List.findPair({ &quot;a&quot;, &quot;B&quot;, &quot;c&quot; }, function(value, index) return value == string.upper(v) end) -- ( 2, &quot;B&quot; )   "
    },
    {
        "title": "first​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#first",
        "content": "&lt;/&gt; List.first( list: {Value}, notSetValue: Value? ) → () Returns the first value in the list. List.first({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }) -- &quot;a&quot;   "
    },
    {
        "title": "flatten​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#flatten",
        "content": "&lt;/&gt; List.flatten( list: {ListOf&lt;Value&gt;}, depth: number? ) → {ListOf&lt;Value&gt;} Returns a flattened list in the same index-order as each Value would appear. List.flatten({ &quot;foo&quot;, { &quot;bar&quot;, &quot;baz&quot;, }, { &quot;bar&quot;, &quot;baz&quot;, }, &quot;quz&quot;, }) -- { &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;quz&quot; }   "
    },
    {
        "title": "forEach​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#forEach",
        "content": "&lt;/&gt; List.forEach( list: {Value}, sideEffect: ( Value, number ) → boolean ) → number While the List is iterated, the sideEffect is executed for every entry. If any call of the sideEffect returns false, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false). List.forEach({ 1, 10, -20, 30 }, function(value, index) return value &gt; 0 end) -- 3   "
    },
    {
        "title": "get​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#get",
        "content": "&lt;/&gt; List.get( list: {Value}, index: number, notSetValue: Value? ) → Value? Returns the value at the given index, otherwise returns notSetValue if the given value is not found. If index is negative, the index will start from the last value. List.get({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 3) -- &quot;c&quot; List.get({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, -1) -- &quot;c&quot; List.get({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 100, &quot;default&quot;) -- &quot;default&quot;   "
    },
    {
        "title": "has​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#has",
        "content": "&lt;/&gt; List.has( list: {Value}, index: number ) → boolean Returns true if the index exists within the List. List.has({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 2) -- true   "
    },
    {
        "title": "includes​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#includes",
        "content": "&lt;/&gt; List.includes( list: {Value}, query: Value ) → boolean Returns true if the value is found within the List. List.includes({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, &quot;b&quot;) -- true   "
    },
    {
        "title": "indexOf​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#indexOf",
        "content": "&lt;/&gt; List.indexOf( list: {Value}, searchValue: Value ) → number? Returns the index of the value if found within the List, otherwise returns nil. List.indexOf({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, &quot;b&quot;) -- 2   "
    },
    {
        "title": "insert​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#insert",
        "content": "&lt;/&gt; List.insert( list: {Value}, index: number, ...: Value ) → {Value} Inserts values given starting from the given index, pushing existing values towards the end. The inserted value will be clamped to the beginning or end of the List if the given index is out of bounds. List.insert({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 2, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;) -- { &quot;a&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;, &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "joinAsString​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#joinAsString",
        "content": "&lt;/&gt; List.joinAsString( list: {Value}, separator: string? ) → string Joins values together as a string, inserting a separator between each. The default separator is &quot;,&quot;. List.joinAsString({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, &quot;, &quot;) -- &quot;a, b, c&quot;   "
    },
    {
        "title": "last​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#last",
        "content": "&lt;/&gt; List.last( list: {Value}, notSetValue: Value? ) → Value? Returns the last value in the List. Returns notSetValue if the List is empty. List.last({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }) -- &quot;c&quot; List.last({ }, &quot;default&quot;) -- &quot;default&quot;   "
    },
    {
        "title": "map​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#map",
        "content": "&lt;/&gt; List.map( list: {Value}, mapper: ( Value, number ) → ( NewValue, number? ) ) → {NewValue} Returns a List with values passed through a mapper function. Returning a second value in the mapper function will reassign the index. If mapper returns nil, the entry will be filtered. List.map({ 1, 2, 3 }, function(value, index) return value * 10 end) -- { 10, 20, 30 }   "
    },
    {
        "title": "max​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#max",
        "content": "&lt;/&gt; List.max( list: {Value}, comparator: (( Value, Value ) → boolean)? ) → ( Value, number? ) Returns the maximum value in this List. If any values are comparatively equivalent, the first one found will be returned. The comparator is used in the same way as table.sort. If it is not provided, the default comparator is &gt;. List.max({ 10, 200, 30 }) -- ( 200, 2 ) List.max({ child, teen, adult }, function(personA, personB) return personA.age &gt; personB.age end) -- ( adult, 3 )   "
    },
    {
        "title": "merge​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#merge",
        "content": "&lt;/&gt; List.merge(...: {any}) → {any} Returns a merged result of all given Lists. If freeze.None is a value assigned to an index, it will delete that index from the resulting List. List.merge({ 10, nil, 30 }, { nil, 20, nil }) -- { 10, 20, 30 } List.merge({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, { &quot;x&quot; }, { nil, &quot;y&quot;, freeze.None }) -- { &quot;x&quot;, &quot;y&quot; }   "
    },
    {
        "title": "min​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#min",
        "content": "&lt;/&gt; List.min( list: {Value}, comparator: (( Value, Value ) → boolean)? ) → ( Value, number? ) Returns the minimum value in this List. If any values are comparatively equivalent, the first one found will be returned. The comparator is used in the same way as table.sort. If it is not provided, the default comparator is &gt;. List.min({ 10, 200, 30 }) -- 10 List.min({ child, teen, adult }, function(personA, personB) return personA.age &gt; personB.age end) -- child   "
    },
    {
        "title": "pop​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#pop",
        "content": "&lt;/&gt; List.pop( list: {Value}, amount: number? ) → {Value} Returns a List excluding the last index of this List. This will repeat multiple times if given the optional amount argument and will always pop at least once. List.pop({ 10, 20, 30 }) -- { 10, 20 } List.pop({ 10, 20, 30 }, 2) -- { 10 }   "
    },
    {
        "title": "push​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#push",
        "content": "&lt;/&gt; List.push( list: {Value}, ...: Value ) → {Value} Returns a List with the provided values appended at the end of the List. List.push({ 10, 20, 30 }, 40, 50, 60) -- { 10, 20, 30, 40, 50, 60 }   "
    },
    {
        "title": "reduce​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#reduce",
        "content": "&lt;/&gt; List.reduce( list: {Value}, reducer: ( T, Value, number ) → T, initialReduction: T ) → T Returns the final reduced result by iterating the List and calling the reducer for every entry and passing along the reduced value. List.reduce({ 10, 20, 30 }, function(reduction, value) return reduction + value end, 0) -- 60   "
    },
    {
        "title": "reduceRight​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#reduceRight",
        "content": "&lt;/&gt; List.reduceRight( list: {Value}, reducer: ( T, Value, number ) → T, initialReduction: T ) → T Returns the final reduced result by iterating the list in reverse (from the right side) and calling the reducer for every entry and passing along the reduced value. List.reduceRight({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, function(reduction, value) return reduction .. value end, &quot;&quot;) -- &quot;cba&quot;   "
    },
    {
        "title": "remove​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#remove",
        "content": "&lt;/&gt; List.remove( list: {Value}, ...: number ) → {Value} Returns a List which excludes this index. Values at indices above index are shifted down by 1 to fill the position. index may be a negative number, which indexes back from the end of the list. list.remove(-1) removes the last item in the list. If the given given results in an index that is out of bounds, it will return the original list with no changes. List.remove({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; }, 3) -- { &quot;a&quot;, &quot;b&quot;, &quot;d&quot; }   "
    },
    {
        "title": "removeValue​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#removeValue",
        "content": "&lt;/&gt; List.removeValue( list: {Value}, ...: Value ) → {Value} Returns a List having removed all entries with the given value. If no values are present, it will return the original List with no changes. List.removeValue({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, &quot;a&quot;) -- { &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "rest​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#rest",
        "content": "&lt;/&gt; List.rest(list: {Value}) → {Value} Returns a List containing all entries except the first. Equivalent to slice(2). See List.slice for more information. List.rest({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }) -- { &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "reverse​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#reverse",
        "content": "&lt;/&gt; List.reverse(list: {Value}) → {Value} Returns a List in reverse order. List.reverse({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }) -- { &quot;c&quot;, &quot;b&quot;, &quot;a&quot; }   "
    },
    {
        "title": "set​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#set",
        "content": "&lt;/&gt; List.set( list: {Value}, index: number, value: Value ) → {Value} Returns a List which includes value at index. If index already exists, it will be replaced. Returns the original List if no changes were made. List.set({&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}, 1, &quot;A&quot;) -- { &quot;A&quot;, &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "shift​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#shift",
        "content": "&lt;/&gt; List.shift( list: {Value}, amount: number? ) → {Value} Returns a List excluding the first index in this List, shifting all other values to a lower index. If amount is not provided, it will default to 1. Passing an amount greater than the length of the given List will result in an empty List. List.shift({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }) -- { &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "skip​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#skip",
        "content": "&lt;/&gt; List.skip( list: {Value}, amount: number ) → {Value} Returns a List which excludes the first amount of entries. List.skip({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; }, 2) -- { &quot;c&quot;, &quot;d&quot; }   "
    },
    {
        "title": "slice​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#slice",
        "content": "&lt;/&gt; List.slice( list: {Value}, from: number?, to: number? ) → {Value} Returns a List that includes the range [from, to). If from is negative, it is offset from the end of the list. slice(-2) returns a list of the last two entries. If it is not provided, the new list will begin at the first entry. If to is negative, it is offset from the end of the list. slice(1, -1) returns a list of everything but the last entry. If it is not provided, the new list will continue through the end of the list. List.slice({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 2) -- { &quot;b&quot;, &quot;c&quot; } List.slice({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, -1) -- { &quot;c&quot; } List.slice({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 1, -1) -- { &quot;a&quot;, &quot;b&quot; }   "
    },
    {
        "title": "some​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#some",
        "content": "&lt;/&gt; List.some( list: {Value}, predicate: ( Value, number ) → boolean ) → boolean Returns true if predicate returns true for any entry in the List. List.some({ 1, 2, 3 }, function(value, index) return value % 2 == 0 end) -- true   "
    },
    {
        "title": "sort​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#sort",
        "content": "&lt;/&gt; List.sort( list: {Value}, comparator: (( Value, Value ) → boolean)? ) → () Returns a List which includes the same entries, sorted by using a comparator. If a comparator is not provided, a default comparator uses &lt; and &gt;. List.sort({ 4, 2, 1, 3 }) -- { 1, 2, 3, 4 }   "
    },
    {
        "title": "take​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#take",
        "content": "&lt;/&gt; List.take( list: {Value}, amount: number ) → {Value} Returns a List which includes the first amount of entires. List.take({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; }, 2) -- { &quot;a&quot;, &quot;b&quot; }   "
    },
    {
        "title": "takeLast​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#takeLast",
        "content": "&lt;/&gt; List.takeLast( list: {Value}, amount: number ) → {Value} Returns a List which includes the last amount of entires. List.takeLast({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 2) -- { &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "unshift​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#unshift",
        "content": "&lt;/&gt; List.unshift( list: {Value}, ...: Value ) → {Value} Returns a List with the provided values prepended, shifting other values ahead to higher indices. List.unshift({ &quot;b&quot;, &quot;c&quot; }, &quot;a&quot;) -- { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }   "
    },
    {
        "title": "update​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#update",
        "content": "&lt;/&gt; List.update( list: {Value}, index: number, updater: (Value?) → Value, notSetValue: Value? ) → {Value} Returns a List with the entry at index updated to the result of updater. If the entry does not exist, updater will be given notSetValue or nil. List.update({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 2, function(value) return string.rep(value, 5) end) -- { &quot;a&quot;, &quot;bbbbb&quot;, &quot;c&quot; } List.update({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, 4, function(value) return string.rep(value, 5) end, &quot;d&quot;) -- { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;ddddd&quot; }   "
    },
    {
        "title": "zip​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#zip",
        "content": "&lt;/&gt; List.zip(...: {Value}) → {{Value}} Returns a List with all lists given &quot;zipped&quot; together. The length of the List is the length of the shortest provided list. List.zip({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, { &quot;x&quot;, &quot;y&quot;, &quot;z&quot; }) -- { { &quot;a&quot;, &quot;x&quot; }, { &quot;b&quot;, &quot;y&quot; }, { &quot;c&quot;, &quot;z&quot; } } List.zip({ alice, bertram, charlie }, { alexander, betty, candice, dennis }) -- { { alice, alexander }, { bertram, betty }, { charlie, candice } } -- Note: dennis is omitted and not paired.   "
    },
    {
        "title": "append​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#append",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [List.push] instead. List.append( list: {Value}, ...: Value ) → {Value}   "
    },
    {
        "title": "create​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#create",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [table.create] instead. List.create( count: number, value: Value? ) → {Value}   "
    },
    {
        "title": "findWhere​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#findWhere",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [List.find] instead. List.findWhere( list: {Value}, predicate: ( Value, number ) → boolean, from: never ) → Value?   "
    },
    {
        "title": "findWhereLast​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#findWhereLast",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [List.reverse] and then [List.find] instead. List.findWhereLast( list: {Value}, predicate: ( Value, number ) → boolean, from: never? ) → Value?   "
    },
    {
        "title": "join​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#join",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [List.merge] instead. List.join(...: {any}) → {any}   "
    },
    {
        "title": "removeIndex​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#removeIndex",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [List.remove] instead. List.removeIndex( list: {Value}, index: number ) → {Value}   "
    },
    {
        "title": "removeIndices​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#removeIndices",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [List.remove] instead. List.removeIndices( list: {Value}, ...: number ) → {Value}   "
    },
    {
        "title": "removeValues​",
        "type": 1,
        "pageTitle": "List",
        "url": "/freeze/api/List#removeValues",
        "content": "deprecated in v0.0.4 &lt;/&gt; This was deprecated in v0.0.4 Use [List.removeValue] instead. List.removeValues( list: {Value}, ...: Value ) → {Value}  "
    }
]