[{"title":"Freeze","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Prior art‚Äã","type":1,"pageTitle":"Freeze","url":"docs/intro#prior-art","content":"Freeze is takes inspiration from: Llama by freddylistImmutable.js "},{"title":"How does immutability help?","type":0,"sectionRef":"#","url":"docs/WhyImmutable","content":"How does immutability help? üèóÔ∏è Under construction In the meantime, take a look at what these other authors have to say: LlamaImmutable.js","keywords":""},{"title":"Demonstration","type":0,"sectionRef":"#","url":"docs/Demonstration","content":"","keywords":""},{"title":"Functional‚Äã","type":1,"pageTitle":"Demonstration","url":"docs/Demonstration#functional","content":"Other popular Lua implementations1 of immutable data structures typically offer this functional approach: local oldList = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; } local newList = Freeze.List.set(oldList, 1, &quot;value&quot;) Copy This comes with a few benefits, such as knowing we will always get a Luau table type as a result. "},{"title":"Class‚Äã","type":1,"pageTitle":"Demonstration","url":"docs/Demonstration#class","content":"Freeze also offers a class-based approach to writing immutable data structures.2 local oldList = Freeze.List({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }) local newList = oldList.set(1, &quot;value&quot;).toLuau() Copy This makes it easy to chain together operations to create a new data structure. local oldList = Freeze.List({ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; }) local newList = oldList.map(string.upper).reverse().remove(1) -- List( &quot;C&quot;, &quot;B&quot;, &quot;A&quot; ) Copy This does come with a caveat. Most Luau code written may expect a Luau table data type without any class decorations. If your code is expecting a Luau table data type, be sure to convert your result via toLuau. local luauTable: { string } = newList.toLuau() Copy "},{"title":"API Reference‚Äã","type":1,"pageTitle":"Demonstration","url":"docs/Demonstration#api-reference","content":"Check out the API Reference to see what else Freeze is capable of! Such as Llama.‚Ü©Immutable.js was a heavy inspiration.‚Ü© "},{"title":"Migrating From Llama","type":0,"sectionRef":"#","url":"docs/MigratingFromLlama","content":"","keywords":""},{"title":"Llama‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#llama","content":""},{"title":".equalObjects‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#equalobjects","content":"Not implemented. See Freeze's equals instead. "},{"title":".isEmpty‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#isempty","content":"Not implemented.Use Freeze.Map.isEmpty or Freeze.List.isEmpty instead. "},{"title":".Dictionary‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#dictionary","content":""},{"title":".copy‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#copy","content":"Not implemented. Use table.clone instead. "},{"title":".copyDeep‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#copydeep","content":"Not implemented. Reconsider if you really need this. "},{"title":".equals‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#equals","content":"Freeze.Map.equals will perform value-equality instead of reference-equalityFreeze.Map.equals only accepts two objects to compare between instead of varags argumentsFreeze.Map.equals will treat nil and void as values, where Freeze.Map.equals would ignore these arguments "},{"title":".equalsDeep‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#equalsdeep","content":"Not implemented. "},{"title":".fromLists‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#fromlists","content":"Not implemented.Consider Freeze.Map.of instead. "},{"title":".mergeDeep‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#mergedeep","content":"Not implemented. "},{"title":".removeKeys‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#removekeys","content":"Not implemented.Consider Freeze.Map.filter instead. "},{"title":".removeValues‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#removevalues","content":"Not implemented.Consider Freeze.Map.filter instead. "},{"title":".update‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#update","content":"Freeze.Map.update requires an updater function while Llama's was optional.Freeze.Map.update's updater signature is (Value) -&gt; (Value) instead of Llama's (Value, Key) -&gt; (Value).Freeze.Map.update final argument is notSetValue instead of a callback function. -- Freeze Freeze.Map.update(dictionary, key, function(value) return string.upper(value) end, &quot;default value&quot;) -- Llama Llama.Dictionary.update(dictionary, key, function(value, key) return string.upper(value) end, function(key) return &quot;default value&quot; end) Copy "},{"title":"List‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#list","content":""},{"title":".concatDeep‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#concatdeep","content":"Not implemented. "},{"title":".copy‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#copy-1","content":"Not implemented. Consider table.clone instead. "},{"title":".copyDeep‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#copydeep-1","content":"Not implemented. Reconsider if you really need this. "},{"title":".create‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#create","content":"Not implemented. Consider table.create instead. "},{"title":".equals‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#equals-1","content":"Freeze.List.equals will perform value-equality instead of reference-equalityFreeze.List.equals only accepts two objects to compare between instead of varags argumentsFreeze.List.equals will treat nil and void as values, where Freeze.List.equals would ignore these arguments "},{"title":".equalsDeep‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#equalsdeep-1","content":"Not implemented. "},{"title":".find‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#find","content":"Freeze.List.find accepts a predicate instead of a value.Consider table.find if you want to use a static value. -- Freeze Freeze.List.find(list, function(value) return value == &quot;foo&quot; end) -- Llama Llama.List.find(list, &quot;foo&quot;) Copy "},{"title":".findLast‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#findlast","content":"Freeze.List.findLast accepts a predicate instead of a value. -- Freeze Freeze.List.findLast(list, function(value) return value == &quot;foo&quot; end) -- Llama Llama.List.findLast(list, &quot;foo&quot;) Copy "},{"title":".findWhere‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#findwhere","content":"Not implemented.Equivalent to Freeze.List.find. "},{"title":".findWhereLast‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#findwherelast","content":"Not implemented.Equivalent to Freeze.List.findLast. "},{"title":".insert‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#insert","content":"Allows index to be out of bounds. Will not throw. "},{"title":".removeIndices‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#removeindices","content":"Not implemented.Consider Freeze.List.filter instead. "},{"title":".removeValues‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#removevalues-1","content":"Not implemented.Consider Freeze.List.filter instead. "},{"title":".set‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#set","content":"Allows index to be out of bounds. Will not throw. "},{"title":".slice‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#slice","content":"Allows index to be out of bounds. Will not throw.Using a negative number will slice from the end of the list. "},{"title":".splice‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#splice","content":"Not implemented. "},{"title":".toSet‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#toset","content":"Not implemented. "},{"title":".update‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#update-1","content":"Freeze.List.update requires an updater function while Llama's was optional.Freeze.List.update's updater signature is (Value) -&gt; (Value) instead of Llama's (Value, Key) -&gt; (Value).Freeze.List.update final argument is notSetValue instead of a callback function. -- Freeze Freeze.List.update(list, key, function(value) return string.upper(value) end, &quot;default value&quot;) -- Llama Llama.List.update(list, key, function(value, key) return string.upper(value) end, function(key) return &quot;default value&quot; end) Copy "},{"title":".zipAll‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#zipall","content":"Not implemented. "},{"title":"Set‚Äã","type":1,"pageTitle":"Migrating From Llama","url":"docs/MigratingFromLlama#set-1","content":"Not implemented. "}]